import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
  /** The builtin Time type */
  Time: any;
};

export type Asset = Node & {
  __typename?: 'Asset';
  assetTags?: Maybe<Array<AssetTag>>;
  children?: Maybe<Array<Asset>>;
  id: Scalars['ID'];
  location?: Maybe<Location>;
  locationID?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  parent?: Maybe<Asset>;
  parentID?: Maybe<Scalars['ID']>;
  tags?: Maybe<Array<Tag>>;
};

/** A connection to a list of items. */
export type AssetConnection = {
  __typename?: 'AssetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssetEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AssetEdge = {
  __typename?: 'AssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Asset>;
};

export type AssetTag = Node & {
  __typename?: 'AssetTag';
  asset: Asset;
  assetID: Scalars['ID'];
  id: Scalars['ID'];
  tag: Tag;
  tagID: Scalars['ID'];
};

/**
 * AssetTagWhereInput is used for filtering AssetTag objects.
 * Input was generated by ent.
 */
export type AssetTagWhereInput = {
  and?: InputMaybe<Array<AssetTagWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<AssetTagWhereInput>;
  or?: InputMaybe<Array<AssetTagWhereInput>>;
};

/**
 * AssetWhereInput is used for filtering Asset objects.
 * Input was generated by ent.
 */
export type AssetWhereInput = {
  and?: InputMaybe<Array<AssetWhereInput>>;
  /** asset_tags edge predicates */
  hasAssetTags?: InputMaybe<Scalars['Boolean']>;
  hasAssetTagsWith?: InputMaybe<Array<AssetTagWhereInput>>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']>;
  hasChildrenWith?: InputMaybe<Array<AssetWhereInput>>;
  /** location edge predicates */
  hasLocation?: InputMaybe<Scalars['Boolean']>;
  hasLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']>;
  hasParentWith?: InputMaybe<Array<AssetWhereInput>>;
  /** tags edge predicates */
  hasTags?: InputMaybe<Scalars['Boolean']>;
  hasTagsWith?: InputMaybe<Array<TagWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** location_id field predicates */
  locationID?: InputMaybe<Scalars['ID']>;
  locationIDIn?: InputMaybe<Array<Scalars['ID']>>;
  locationIDIsNil?: InputMaybe<Scalars['Boolean']>;
  locationIDNEQ?: InputMaybe<Scalars['ID']>;
  locationIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  locationIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<AssetWhereInput>;
  or?: InputMaybe<Array<AssetWhereInput>>;
  /** parent_id field predicates */
  parentID?: InputMaybe<Scalars['ID']>;
  parentIDIn?: InputMaybe<Array<Scalars['ID']>>;
  parentIDIsNil?: InputMaybe<Scalars['Boolean']>;
  parentIDNEQ?: InputMaybe<Scalars['ID']>;
  parentIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  parentIDNotNil?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateAssetInput is used for create Asset object.
 * Input was generated by ent.
 */
export type CreateAssetInput = {
  childIDs?: InputMaybe<Array<Scalars['ID']>>;
  locationID?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  parentID?: InputMaybe<Scalars['ID']>;
  tagIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateLocationInput is used for create Location object.
 * Input was generated by ent.
 */
export type CreateLocationInput = {
  childIDs?: InputMaybe<Array<Scalars['ID']>>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  parentID?: InputMaybe<Scalars['ID']>;
};

/**
 * CreateTagInput is used for create Tag object.
 * Input was generated by ent.
 */
export type CreateTagInput = {
  assetIDs?: InputMaybe<Array<Scalars['ID']>>;
  name?: InputMaybe<Scalars['String']>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  childIDs?: InputMaybe<Array<Scalars['ID']>>;
  name?: InputMaybe<Scalars['String']>;
  parentID?: InputMaybe<Scalars['ID']>;
};

export type Location = Node & {
  __typename?: 'Location';
  children?: Maybe<Array<Location>>;
  deletedAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  parent?: Maybe<Location>;
  parentID?: Maybe<Scalars['ID']>;
  stats?: Maybe<LocationStats>;
};

/** A connection to a list of items. */
export type LocationConnection = {
  __typename?: 'LocationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LocationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LocationEdge = {
  __typename?: 'LocationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Location>;
};

export type LocationStats = {
  __typename?: 'LocationStats';
  totalItems?: Maybe<Scalars['Int']>;
  totalLocations?: Maybe<Scalars['Int']>;
  totalValue?: Maybe<Scalars['Int']>;
};

/**
 * LocationWhereInput is used for filtering Location objects.
 * Input was generated by ent.
 */
export type LocationWhereInput = {
  and?: InputMaybe<Array<LocationWhereInput>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']>;
  hasChildrenWith?: InputMaybe<Array<LocationWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']>;
  hasParentWith?: InputMaybe<Array<LocationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<LocationWhereInput>;
  or?: InputMaybe<Array<LocationWhereInput>>;
  /** parent_id field predicates */
  parentID?: InputMaybe<Scalars['ID']>;
  parentIDIn?: InputMaybe<Array<Scalars['ID']>>;
  parentIDIsNil?: InputMaybe<Scalars['Boolean']>;
  parentIDNEQ?: InputMaybe<Scalars['ID']>;
  parentIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  parentIDNotNil?: InputMaybe<Scalars['Boolean']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createAsset: Asset;
  createLocation: Location;
  createTag: Tag;
  createUser: User;
  deleteLocation: Scalars['Boolean'];
  updateAsset: Asset;
  updateLocation: Location;
  updateTag: Tag;
  updateUser: User;
};


export type MutationCreateAssetArgs = {
  input: CreateAssetInput;
};


export type MutationCreateLocationArgs = {
  input: CreateLocationInput;
};


export type MutationCreateTagArgs = {
  input: CreateTagInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationDeleteLocationArgs = {
  id: Scalars['ID'];
};


export type MutationUpdateAssetArgs = {
  id: Scalars['ID'];
  input: UpdateAssetInput;
};


export type MutationUpdateLocationArgs = {
  id: Scalars['ID'];
  input: UpdateLocationInput;
};


export type MutationUpdateTagArgs = {
  id: Scalars['ID'];
  input: UpdateTagInput;
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID'];
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Query = {
  __typename?: 'Query';
  assets: AssetConnection;
  locations: LocationConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  tags: TagConnection;
  users: UserConnection;
};


export type QueryAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LocationWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TagWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserWhereInput>;
};

export type Tag = Node & {
  __typename?: 'Tag';
  asset?: Maybe<Array<Asset>>;
  assetTag?: Maybe<Array<AssetTag>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type TagConnection = {
  __typename?: 'TagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TagEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type TagEdge = {
  __typename?: 'TagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Tag>;
};

/**
 * TagWhereInput is used for filtering Tag objects.
 * Input was generated by ent.
 */
export type TagWhereInput = {
  and?: InputMaybe<Array<TagWhereInput>>;
  /** asset edge predicates */
  hasAsset?: InputMaybe<Scalars['Boolean']>;
  /** asset_tag edge predicates */
  hasAssetTag?: InputMaybe<Scalars['Boolean']>;
  hasAssetTagWith?: InputMaybe<Array<AssetTagWhereInput>>;
  hasAssetWith?: InputMaybe<Array<AssetWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<TagWhereInput>;
  or?: InputMaybe<Array<TagWhereInput>>;
};

/**
 * UpdateAssetInput is used for update Asset object.
 * Input was generated by ent.
 */
export type UpdateAssetInput = {
  addChildIDs?: InputMaybe<Array<Scalars['ID']>>;
  addTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearChildren?: InputMaybe<Scalars['Boolean']>;
  clearLocation?: InputMaybe<Scalars['Boolean']>;
  clearName?: InputMaybe<Scalars['Boolean']>;
  clearParent?: InputMaybe<Scalars['Boolean']>;
  clearTags?: InputMaybe<Scalars['Boolean']>;
  locationID?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  parentID?: InputMaybe<Scalars['ID']>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeTagIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateLocationInput is used for update Location object.
 * Input was generated by ent.
 */
export type UpdateLocationInput = {
  addChildIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearChildren?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  clearName?: InputMaybe<Scalars['Boolean']>;
  clearParent?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  parentID?: InputMaybe<Scalars['ID']>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateTagInput is used for update Tag object.
 * Input was generated by ent.
 */
export type UpdateTagInput = {
  addAssetIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearAsset?: InputMaybe<Scalars['Boolean']>;
  clearName?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeAssetIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addChildIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearChildren?: InputMaybe<Scalars['Boolean']>;
  clearName?: InputMaybe<Scalars['Boolean']>;
  clearParent?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  parentID?: InputMaybe<Scalars['ID']>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']>>;
};

export type User = Node & {
  __typename?: 'User';
  children?: Maybe<Array<User>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  parent?: Maybe<User>;
  parentID?: Maybe<Scalars['ID']>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']>;
  hasChildrenWith?: InputMaybe<Array<UserWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']>;
  hasParentWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** parent_id field predicates */
  parentID?: InputMaybe<Scalars['ID']>;
  parentIDIn?: InputMaybe<Array<Scalars['ID']>>;
  parentIDIsNil?: InputMaybe<Scalars['Boolean']>;
  parentIDNEQ?: InputMaybe<Scalars['ID']>;
  parentIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  parentIDNotNil?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateLocationMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdateLocationInput;
}>;


export type UpdateLocationMutation = { __typename?: 'Mutation', updateLocation: { __typename?: 'Location', id: string } };

export type CreateLocationMutationVariables = Exact<{
  input: CreateLocationInput;
}>;


export type CreateLocationMutation = { __typename?: 'Mutation', createLocation: { __typename?: 'Location', id: string } };

export type GetAllLocationsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllLocationsQuery = { __typename?: 'Query', locations: { __typename?: 'LocationConnection', edges?: Array<{ __typename?: 'LocationEdge', node?: { __typename?: 'Location', id: string, name?: string | null, description?: string | null, parentID?: string | null, children?: Array<{ __typename?: 'Location', id: string, name?: string | null, description?: string | null, children?: Array<{ __typename?: 'Location', id: string, name?: string | null, description?: string | null }> | null }> | null } | null } | null> | null } };

export type GetAllLocationsWithParentsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllLocationsWithParentsQuery = { __typename?: 'Query', locations: { __typename?: 'LocationConnection', edges?: Array<{ __typename?: 'LocationEdge', node?: { __typename?: 'Location', id: string, name?: string | null, parentID?: string | null, parent?: { __typename?: 'Location', id: string, name?: string | null, parentID?: string | null, parent?: { __typename?: 'Location', id: string, name?: string | null, parentID?: string | null, parent?: { __typename?: 'Location', id: string, name?: string | null, parentID?: string | null, parent?: { __typename?: 'Location', id: string, name?: string | null, parentID?: string | null } | null } | null } | null } | null } | null } | null> | null } };


export const UpdateLocationDocument = gql`
    mutation UpdateLocation($id: ID!, $input: UpdateLocationInput!) {
  updateLocation(id: $id, input: $input) {
    id
  }
}
    `;
export type UpdateLocationMutationFn = Apollo.MutationFunction<UpdateLocationMutation, UpdateLocationMutationVariables>;

/**
 * __useUpdateLocationMutation__
 *
 * To run a mutation, you first call `useUpdateLocationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLocationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLocationMutation, { data, loading, error }] = useUpdateLocationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateLocationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLocationMutation, UpdateLocationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLocationMutation, UpdateLocationMutationVariables>(UpdateLocationDocument, options);
      }
export type UpdateLocationMutationHookResult = ReturnType<typeof useUpdateLocationMutation>;
export type UpdateLocationMutationResult = Apollo.MutationResult<UpdateLocationMutation>;
export type UpdateLocationMutationOptions = Apollo.BaseMutationOptions<UpdateLocationMutation, UpdateLocationMutationVariables>;
export const CreateLocationDocument = gql`
    mutation CreateLocation($input: CreateLocationInput!) {
  createLocation(input: $input) {
    id
  }
}
    `;
export type CreateLocationMutationFn = Apollo.MutationFunction<CreateLocationMutation, CreateLocationMutationVariables>;

/**
 * __useCreateLocationMutation__
 *
 * To run a mutation, you first call `useCreateLocationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLocationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLocationMutation, { data, loading, error }] = useCreateLocationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateLocationMutation(baseOptions?: Apollo.MutationHookOptions<CreateLocationMutation, CreateLocationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateLocationMutation, CreateLocationMutationVariables>(CreateLocationDocument, options);
      }
export type CreateLocationMutationHookResult = ReturnType<typeof useCreateLocationMutation>;
export type CreateLocationMutationResult = Apollo.MutationResult<CreateLocationMutation>;
export type CreateLocationMutationOptions = Apollo.BaseMutationOptions<CreateLocationMutation, CreateLocationMutationVariables>;
export const GetAllLocationsDocument = gql`
    query GetAllLocations {
  locations {
    edges {
      node {
        id
        name
        description
        parentID
        children {
          id
          name
          description
          children {
            id
            name
            description
          }
          children {
            id
            name
            description
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetAllLocationsQuery__
 *
 * To run a query within a React component, call `useGetAllLocationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllLocationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllLocationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllLocationsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllLocationsQuery, GetAllLocationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllLocationsQuery, GetAllLocationsQueryVariables>(GetAllLocationsDocument, options);
      }
export function useGetAllLocationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllLocationsQuery, GetAllLocationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllLocationsQuery, GetAllLocationsQueryVariables>(GetAllLocationsDocument, options);
        }
export type GetAllLocationsQueryHookResult = ReturnType<typeof useGetAllLocationsQuery>;
export type GetAllLocationsLazyQueryHookResult = ReturnType<typeof useGetAllLocationsLazyQuery>;
export type GetAllLocationsQueryResult = Apollo.QueryResult<GetAllLocationsQuery, GetAllLocationsQueryVariables>;
export const GetAllLocationsWithParentsDocument = gql`
    query GetAllLocationsWithParents {
  locations {
    edges {
      node {
        id
        name
        parentID
        parent {
          id
          name
          parentID
          parent {
            id
            name
            parentID
            parent {
              id
              name
              parentID
              parent {
                id
                name
                parentID
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetAllLocationsWithParentsQuery__
 *
 * To run a query within a React component, call `useGetAllLocationsWithParentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllLocationsWithParentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllLocationsWithParentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllLocationsWithParentsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllLocationsWithParentsQuery, GetAllLocationsWithParentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllLocationsWithParentsQuery, GetAllLocationsWithParentsQueryVariables>(GetAllLocationsWithParentsDocument, options);
      }
export function useGetAllLocationsWithParentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllLocationsWithParentsQuery, GetAllLocationsWithParentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllLocationsWithParentsQuery, GetAllLocationsWithParentsQueryVariables>(GetAllLocationsWithParentsDocument, options);
        }
export type GetAllLocationsWithParentsQueryHookResult = ReturnType<typeof useGetAllLocationsWithParentsQuery>;
export type GetAllLocationsWithParentsLazyQueryHookResult = ReturnType<typeof useGetAllLocationsWithParentsLazyQuery>;
export type GetAllLocationsWithParentsQueryResult = Apollo.QueryResult<GetAllLocationsWithParentsQuery, GetAllLocationsWithParentsQueryVariables>;